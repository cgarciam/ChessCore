package chessprogram.magic;

import chessprogram.god.Art;
import chessprogram.god.BitboardResources;
import chessprogram.god.Chessboard;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

import static chessprogram.god.BitOperations.*;

public class MagicGenerator {
    
    /*
     magic move-bitboard generation technique consists of four key steps:

Mask the relevant occupancy bits to form a key. For example if you had a rook on a1, the relevant occupancy bits will be from a2-a7 and b1-g1.
Multiply the key by a "magic number" to obtain an index mapping. This magic number can be generated by brute-force trial and error quite easily although it isn't 100% certain that the magic number is the best possible (see step 3).
Right shift the index mapping by 64-n bits to create an index, where n is the number of bits in the index. A better magic number will have less bits required in the index.
Use the index to reference a preinitialized move database.
The following illustration should give an impression, how magic bitboards work. All masked relevant occupied bits are perfectly hashed to the consecutive occupied state to index the pre-calculated attack-sets. Constructive collisions, where different occupancies map same attack-sets - since different bits are outer redundant bits "behind" the first blocker, are desired and even necessary to apply a perfect hashing with N bits.
     */

    public static void main (String[] args){
        new MagicGenerator();
    }

    MagicGenerator(){
        Chessboard board = new Chessboard();

        long whiteRook = 0x0000000000000080L;

        final List<Long> longs = maskHelperRook(board);

        final List<Long> plop = plop(board, longs);
        System.out.println(plop);

    }

    List<Long> plop(Chessboard board, List<Long> longs){

        Random r = new Random(1000);
        
        List<Long> answers = new ArrayList<>();
        
        int limit = longs.size();
        for (int l = 0; l < limit; l++){
            final Long aLong = longs.get(l);
            final long destinationMagic = destinationMagic(aLong);
//            Art.printLong(aLong);
//            Art.printLong(destinationMagic);
            long i = 0;
            while (true){
                i++;
                
                // numbers with fewer bits are better
                final long possibleAnswer = (r.nextLong() & r.nextLong() & r.nextLong());
                
//                System.out.println("i: "+ i+ " poss: " + possibleAnswer);
//                Art.printLong((aLong * possibleAnswer));
                if (aLong * possibleAnswer == destinationMagic) {
                    answers.add(possibleAnswer);
                    System.out.println("Possible answer found after "+ i+" tries.");
                    Art.printLong(possibleAnswer);
                    System.out.println("long * possibleanswer = " +(aLong * possibleAnswer));
                    break;
                }
                if (i > 1_000_000_000L){
                    answers.add(null);
                    System.out.println("breaking");
                    System.out.println("-------------");
                    break;
                }
            }
            
        }
        return answers;
    }

    // todo, ignore final row, file ?
    List<Long> maskHelperRook(Chessboard board) {
        List<Long> things = new ArrayList<>();

        for (int row = 0; row < 8; row++) {
            final long ROW = BitboardResources.ROWS[row];
            for (int file = 0; file < 8; file++) {
                final long FILE = BitboardResources.FILES[file];
                final long pieceOnSquare = ROW & FILE;
                final long OccupancyMaskBlankBoard = pieceOnSquare ^ (ROW | FILE);
                final long OccupancyMask = (ROW | FILE) & ~board.allPieces();

                things.add(OccupancyMask);

            }
        }
        return things;
    }

    private static long firstBit = 0x8000000000000000L;

    long destinationMagic(long l){
        final int i = populationCount(l);
        long destinationMagic = 0x8000000000000000L;
        for (int s = 0; s < i; s++){
            destinationMagic |= (firstBit >>> s);
        }
        return destinationMagic;
    }

}
